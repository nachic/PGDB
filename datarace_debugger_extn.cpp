/*****************************************************************  
This Pintool does following tasks:
1. To Identify each shared Exclusive memory access. 
2. To Extract memory accesses of only Main executable( specifically within .bss section) .
3. To identify whether a thread holds a lock while accessing a particular shared Exclusive memory.
    

Initial bugs :
1.Thread which has put entry in hash table will not show its accesses at shared mem.
Soln - declare region_type

2.Invalid Address insertion into map ( due to mixing pointer with non pointer ).
Soln - reinterpret_cast and type ADDRINT

3.Lock Acquired by Thread ID: 2
Shared Memory Detected : 0x8048657 W 0x80499e0     134519264  TID : 2 Lock No
Shared Memory Declared : 0x8048668 R 0x80499e0     134519264  TID : 2 Lock No
Lock Released by Thread ID: 2
problem tlag[2];
Soln- tflag[3] as there are 3 threads including main thread :)

4. Execution gets stucked at breakpoint generated by pin API and when I do step next "print msg" gets overflowed.
Problem : Infinite Breakpoint
Solution : GDB resumes at context which is passed into PIN_Applicationbreakpoint, hence avoid executing the same analysis routine again.


Current bugs
1. Association of Lock and Memory - A particular memory location should be protected by the same lock everywhere in the program.
Solution :Maintain lockflag for each locks
Optimization
1.list append for handling dynamic number of threads

Suspicious

When thread 1 holding lock, at that time if thread 2 tries to acquire lock
it will block, in that case POINT_BEFORE will set flag

Think

Observe progress of different register instrumentation callbacks
1. What If I could run pintool with image instrumentation and fetch address range which is passed into input to next pintool with remaining instrumentation.
Of course doing multiple instrumentation is an efficiency drawback.

******************************************************************/

#include <stdio.h>
#include <iostream>
#include <sstream>
#include <fstream>
#include <string.h>
#include <cctype>
#include <stdlib.h>
#include <stdlib.h>
#include <iomanip>
#include <vector>
#include <map> 
#include "pin.H"
#include <list>

// Command line switches for this tool.

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool",
    "o","datarace_trace.out","specify output file name");

struct memregion
{
	THREADID tid;
	int region_type;  // 0 for shared read, 1 for write, 2 declare shared excl
	ADDRINT barrier;
	string occurrence;
};

/*struct threadbarrier
{
	THREADID tid;
	std::list<ADDRINT> barvalues;
}barrierlist;
*/

//std::map<ADDRINT,struct memregion> accessmap;
//std::map<ADDRINT,struct memregion>::iterator it;
std::map<ADDRINT, std::list<struct memregion> > accessmap;
std::map<ADDRINT, std::list<struct memregion> >::iterator it;
std::map<ADDRINT, std::list<struct memregion> >::iterator it2;
std::map<THREADID, std::list<ADDRINT> > barriermap;
std::map<THREADID, std::list<ADDRINT> >::iterator bit;
std::map<THREADID, std::list<ADDRINT> >::iterator bit2;

ofstream OutFile;

PIN_LOCK lock;
ADDRINT lowaddr,highaddr;
//int tflag[7];
vector<int> tflag;
static REG RegSkipNextR,RegSkipNextW;
static bool EnableDataraceDetection = true;

static BOOL DebugInterpreter(THREADID, CONTEXT *, const string &, string *, VOID *);
VOID Image(IMG, VOID *);
VOID Instruction(INS, VOID *);
VOID Routine(RTN, VOID *);
VOID Barrier(CONTEXT *, THREADID, ADDRINT *);
VOID RecordMemRead(VOID *, VOID *,CONTEXT *, THREADID, ADDRINT *);
VOID RecordMemWrite(VOID *, VOID *, CONTEXT *, THREADID, ADDRINT *);
VOID RecordLockRoutine(CONTEXT *, THREADID);
VOID RecordUnLockRoutine(CONTEXT *, THREADID);
VOID ThreadStart(THREADID, CONTEXT *, INT32, VOID *);
VOID ThreadFini(THREADID, const CONTEXT *, INT32, VOID *);
VOID Fini(INT32, VOID *);
INT32 Usage();
static std::string TrimWhitespace(const std::string &);
const char * StripPath(const char *);

//static void ConnectDebugger();



/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char *argv[])
{

	// Initialize symbol table code, needed for rtn instrumentation
    PIN_InitSymbols();
	tflag.push_back(0);
	
    if (PIN_Init(argc, argv)) return Usage();
	if (PIN_GetDebugStatus() == DEBUG_STATUS_DISABLED)
    {
        std::cerr << "Application level debugging must be enabled to use this tool.\n";
        std::cerr << "Start Pin with either -appdebug or -appdebug_enable.\n";
        std::cerr << std::flush;
        return 1;
    }
	
	InitLock(&lock);
	OutFile.open(KnobOutputFile.Value().c_str());

	RegSkipNextR = PIN_ClaimToolRegister();
	if (!REG_valid(RegSkipNextR))
	{
	std::cerr << "Not enough virtual registers" << std::endl;
	return 1;
	}
	
	RegSkipNextW = PIN_ClaimToolRegister();
	if (!REG_valid(RegSkipNextW))
	{
	std::cerr << "Not enough virtual registers" << std::endl;
	return 1;
	}

    PIN_AddDebugInterpreter(DebugInterpreter, 0);

	IMG_AddInstrumentFunction(Image, 0);
    INS_AddInstrumentFunction(Instruction, 0);
	RTN_AddInstrumentFunction(Routine, 0);
	
	// Register Analysis routines to be called when a thread begins/ends
    PIN_AddThreadStartFunction(ThreadStart, 0);
    PIN_AddThreadFiniFunction(ThreadFini, 0);
    PIN_AddFiniFunction(Fini, 0);

    // Never returns
    PIN_StartProgram();
   
    return 0;
}

/*
 * This call-back implements the extended debugger commands.
 *
 * Returns: TRUE if we recognize this extended command.
 */
static BOOL DebugInterpreter(THREADID tid, CONTEXT *ctxt, const string &cmd, string *result, VOID *)
{
    std::string line = TrimWhitespace(cmd);
    *result = "";

    if (line == "help")
    {
        result->append("datarace detection on -- Start Identifying any shared Exclusive memory access.\n");
        result->append("datarace detection off -- Stop Detection of shared Exclusive memory access.\n");
		result->append("datarace detection status -- Shows whether Datarace Detection is currently ON or OFF.\n");
		return TRUE;
    }
    else if (line == "datarace detection on")
    {
        if (!EnableDataraceDetection)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
            PIN_RemoveInstrumentation();
            EnableDataraceDetection = true;
            *result = "Datarace Detection enabled.\nAny shared exclusive memory access will be reported hereafter \
until this feature is disabled using command -- datarace detection off.\n";
        }
		else
		{
		    *result = "Datarace Detection is already enabled.\n";	
		}
        return TRUE;
    }
    else if (line == "datarace detection off")
    {
        if (EnableDataraceDetection)
        {
            PIN_RemoveInstrumentation();
            EnableDataraceDetection = false;
            *result = "Datarace Detection disabled.\n";
        }
		else
		{
		    *result = "Datarace Detection is already disabled.\n";	
		}
        return TRUE;
    }
	else if (line == "datarace detection status")
    {
        if (EnableDataraceDetection)
        {
            *result = "Datarace Detection is enabled.\n";
        }
		else
		{
		    *result = "Datarace Detection is disabled.\n";	
		}
        return TRUE;
    }
    
    return FALSE;   /* Unknown command */
}

VOID Image(IMG Img, VOID *v)
{
	if (EnableDataraceDetection)
    {
		unsigned found;
		if(IMG_IsMainExecutable(Img))
		{
			for (SEC sec = IMG_SecHead(Img); SEC_Valid(sec); sec = SEC_Next(sec))
			{ 
				found=SEC_Name(sec).compare(".bss");
			
				if(found==0)
				{
					printf("Address: %x ",SEC_Address(sec));
					std::cout << " =>Section: " << setw(8) << SEC_Address(sec) << " " << SEC_Name(sec) << endl;
					lowaddr=SEC_Address(sec);
					//lowaddr=134519568;
					//lowaddr=134519257;	//global2	
					//lowaddr=IMG_LowAddress(Img);	
					printf("%x\n",lowaddr);
					std::cout << "Low addr: " << lowaddr << '\n';
					OutFile  << "Low addr: " << lowaddr << '\n';
					highaddr=IMG_HighAddress(Img);
					std::cout << "High addr: " << highaddr << '\n';
					OutFile << "High addr: " << highaddr << '\n';
					printf("%x\n",highaddr);
				}			
			}
/*
		std::cout << "Main Executable Loaded " << '\n';
		lowaddr=IMG_LowAddress(Img);
		printf("%x\n",lowaddr);
		std::cout << "Low addr: " << lowaddr << '\n';
		highaddr=IMG_HighAddress(Img);
		std::cout << "High addr: " << highaddr << '\n';
		printf("%x\n",highaddr);

*/	
		}
	}
}

// Is called for every instruction and instruments reads and writes
VOID Instruction(INS ins, VOID *v)
{
    // Instruments memory accesses using a predicated call, i.e.
    // the instrumentation is called iff the instruction will actually be executed.
    //
    // The IA-64 architecture has explicitly predicated instructions. 
    // On the IA-32 and Intel(R) 64 architectures conditional moves and REP 
    // prefixed instructions appear as predicated instructions in Pin.
    
	if (EnableDataraceDetection)
    {
		UINT32 memOperands = INS_MemoryOperandCount(ins);

		// Iterate over each memory operand of the instruction.
		for (UINT32 memOp = 0; memOp < memOperands; memOp++)
		{
			if (INS_MemoryOperandIsRead(ins, memOp))
			{
				INS_InsertPredicatedCall(
					ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead,
					IARG_INST_PTR,
					IARG_MEMORYOP_EA, memOp,
					IARG_CONTEXT,
					IARG_THREAD_ID,
					IARG_REG_REFERENCE, RegSkipNextR,
					IARG_END);
			}
			// Note that in some architectures a single memory operand can be 
			// both read and written (for instance incl (%eax) on IA-32)
			// In that case we instrument it once for read and once for write.
			if (INS_MemoryOperandIsWritten(ins, memOp))
			{
				INS_InsertPredicatedCall(
					ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite,
					IARG_INST_PTR,
					IARG_MEMORYOP_EA, memOp,
					IARG_CONTEXT,
					IARG_THREAD_ID,
					IARG_REG_REFERENCE, RegSkipNextW,
					IARG_END);
			}
		}
	}
}


/* Pin calls this function every time a (NEW RTN)* is executed
   POINT_AFTER or POINT_BEFORE does not matter.
   Even If we put POINT_BEFORE there is no problem, flag specific to one thread is not changed by other threads in our program.
*/
VOID Routine(RTN rtn, VOID *v)
{
	if (EnableDataraceDetection)
    {
		unsigned found;
		
		found=RTN_Name(rtn).compare("__pthread_mutex_lock");
		if(found==0)
		{	
			OutFile <<  RTN_Name(rtn) <<" : " << StripPath(IMG_Name(SEC_Img(RTN_Sec(rtn))).c_str()) << '\n';
				 
			RTN_Open(rtn);   
			// Insert a call at the entry point of a routine to increment the call count
			RTN_InsertCall(
							rtn, IPOINT_AFTER, (AFUNPTR)RecordLockRoutine, 
							IARG_CONTEXT,
							IARG_THREAD_ID,
							IARG_END);
			RTN_Close(rtn);
		}

		found=RTN_Name(rtn).compare("pthread_mutex_unlock");
		if(found==0)
		{	
			OutFile <<  RTN_Name(rtn) <<" : " << StripPath(IMG_Name(SEC_Img(RTN_Sec(rtn))).c_str()) << '\n';
				 
			RTN_Open(rtn);   
			// Insert a call at the entry point of a routine to increment the call count
			RTN_InsertCall(
							rtn, IPOINT_BEFORE, (AFUNPTR)RecordUnLockRoutine, 
							IARG_CONTEXT,
							IARG_THREAD_ID,
							IARG_END);
			RTN_Close(rtn);
		}

		
		found=RTN_Name(rtn).compare("pthread_barier_wait");
		if(found==0)
		{	
			OutFile <<  RTN_Name(rtn) <<" : " << StripPath(IMG_Name(SEC_Img(RTN_Sec(rtn))).c_str()) << '\n';
				 
			RTN_Open(rtn);   
			// Insert a call at the entry point of a routine to increment the call count
			RTN_InsertCall(
							rtn, IPOINT_AFTER, (AFUNPTR)Barrier, 
							IARG_CONTEXT,
							IARG_THREAD_ID,
							IARG_END);
			RTN_Close(rtn);
		}

	}
}

// This function is called before every __pthread_mutex_lock routine
VOID RecordLockRoutine(CONTEXT *ctxt, THREADID tid)
{
    //OutFile << "Lock Acquired by Thread ID: " << tid << '\n';
	tflag[tid]=1;   	
}


// This function is called before every pthread_mutex_unlock routine
VOID RecordUnLockRoutine(CONTEXT *ctxt, THREADID tid)
{
    //OutFile << "Lock Released by Thread ID: " << tid << '\n';
	tflag[tid]=0; 	
}

// This routine is executed every time a thread is created.
VOID ThreadStart(THREADID threadid, CONTEXT *ctxt, INT32 flags, VOID *v)
{
    OutFile << "Thread " << threadid << " Created" << endl;
	//tflag[threadid]=0; // Initially set lock flag as free
	tflag.push_back(0);
}

// This routine is executed every time a thread is destroyed.
VOID ThreadFini(THREADID threadid, const CONTEXT *ctxt, INT32 code, VOID *v)
{
    OutFile << "Thread " << threadid << " Destroyed" << endl ;

}

VOID Fini(INT32 code, VOID *v)
{
	OutFile << "\nDatarace Access Map contains :\n" ;
	//for(it=accessmap.begin();it!=accessmap.end();++it)
	//OutFile << it->first << " => " << it->second.tid << "=>" << it->second.region_type << '\n';	

	int ii;
	for(ii=0; ii < (int)tflag.size(); ii++)
	{
	    cout << tflag[ii] << endl;
	}
	OutFile.close();
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
   	
INT32 Usage()
{
    PIN_ERROR( "This Pintool prints a trace of memory addresses\n" 
              + KNOB_BASE::StringKnobSummary() + "\n");
    return -1;
}


/*
 * Trim whitespace from a line of text.  Leading and trailing whitespace is removed.
 * Any internal whitespace is replaced with a single space (' ') character.
 *
 *  inLine[in]  Input text line.
 *
 * Returns: A string with the whitespace trimmed.
 */
static std::string TrimWhitespace(const std::string &inLine)
{
    std::string outLine = inLine;

    bool skipNextSpace = true;
    for (std::string::iterator it = outLine.begin();  it != outLine.end();  ++it)
    {
        if (std::isspace(*it))
        {
            if (skipNextSpace)
            {
                it = outLine.erase(it);
                if (it == outLine.end())
                    break;
            }
            else
            {
                *it = ' ';
                skipNextSpace = true;
            }
        }
        else
        {
            skipNextSpace = false;
        }
    }
    if (!outLine.empty())
    {
        std::string::reverse_iterator it = outLine.rbegin();
        if (std::isspace(*it))
            outLine.erase(outLine.size()-1);
    }
    return outLine;
}

   
const char * StripPath(const char * path)
{
    const char * file = strrchr(path,'/');
    if (file)
        return file+1;
    else
        return path;
}


// Print a memory read record
VOID RecordMemRead(VOID * ip, VOID * addr,CONTEXT *ctxt, THREADID tid,ADDRINT *regSkipNextR)
{
	
	struct memregion mr;
	ADDRINT address=reinterpret_cast<ADDRINT>(addr);	
	
	if (PIN_GetContextReg(ctxt, RegSkipNextR) == FALSE)
	{

	PIN_SetContextReg(ctxt, RegSkipNextR, TRUE);
	std::ostringstream os;
    if(address >= lowaddr && address <= highaddr)
	{
		//OutFile << "Enter : " << ip << " R " <<  addr << "     " << address << "  TID : " << tid <<'\n';
		//look up memory address
		it=accessmap.find(address);
		if(it==accessmap.end())
		{
			//assign values to memory region structure field
			mr.tid=tid;
			mr.region_type=0;
			mr.occurrence="";
			std::list<struct memregion> tlist;
			tlist.push_back(mr);
			bit=barriermap.find(tid);
			if(bit!=barriermap.end()){
				mr.barrier=address;
				mr.occurrence="AFTER";
			}
			GetLock(&lock,tid+1);
			accessmap.insert( std::pair<ADDRINT,std::list<struct memregion> >(address,tlist));
			OutFile << "Memory Address Inserted : " << ip << " R " <<  addr << "     " << address << "  TID : " << tid <<'\n';
			ReleaseLock(&lock);
		}
		else
		{
				mr.tid=tid;
		                mr.region_type=1;
        	        	mr.occurrence="";
				std::list<struct memregion> ::iterator tit;
				int found = 0;
				for(tit = it->second.begin();tit != it->second.end(); ++tit){
					if(tit->tid == tid){
                                        	if(tit->region_type!=0){
						bit=barriermap.find(tid);
		                                if(bit!=barriermap.end()){
							mr.barrier=address;
							mr.occurrence="AFTER";
						}
						}
						found=1;
						break;
                                        }
				}
				if(found==0){
					mr.barrier=address;
        	        		mr.occurrence="BEFORE";
				        bit=barriermap.find(tid);
                	        	if(bit!=barriermap.end()){
                        	        std::list<ADDRINT>::iterator lit;
                                	int flag = 0;
                                	for(lit=bit->second.begin();lit!=bit->second.end();++lit){
                                        if(*lit==address){
                                                mr.occurrence="AFTER";
                                                flag=1;
                                        }
					}
                                	if(flag == 0)
                                        mr.occurrence="";
                        	}
                	       	//std::list<struct memregion> tlist;
	                       	//tlist.push_back(mr);
				it->second.push_back(mr);

				OutFile << "Shared Memory Declared : " << ip << " R " <<  addr << "     " << address  << "  TID : " << tid <<endl;
				os << "Shared Exclusive Memory : Declared" << '\n';
				os << "Memory Address : " << address << '\n';
				os << "Instruction Address : " << addr << '\n';
				os << "Type of access : READ" << '\n';
				os << "Thread ID assigned by pin : " << tid << '\n';
				
				PIN_ApplicationBreakpoint(ctxt, tid, FALSE, os.str());
			}
			
		}
	}
	}
	*regSkipNextR = FALSE;
	
}


/* Print a memory write record
* 1.Now try out with reinterpret_cast(ip)
* 2.PIN_bp abandons current analysis function and starts at new context, so lock should not be held by tool.
* you have to lock while insertion into map as its not thread safe
*/

VOID RecordMemWrite(VOID * ip, VOID * addr,CONTEXT *ctxt, THREADID tid,ADDRINT *regSkipNextW)
{

	struct memregion mr;
	ADDRINT address=reinterpret_cast<ADDRINT>(addr);
	
	if (PIN_GetContextReg(ctxt, RegSkipNextW) == FALSE)
	{
	PIN_SetContextReg(ctxt, RegSkipNextW, TRUE); // To avoid getting into breakpoint infinite times 
	std::ostringstream os;
  
	if(address >= lowaddr && address <= highaddr)
	{
		it=accessmap.find(address);
		if(it==accessmap.end())
		{
			//assign values to memory region structure field
			mr.tid=tid;
			mr.region_type=0;
			mr.occurrence="";
			std::list<struct memregion> tlist;
			tlist.push_back(mr);
			bit=barriermap.find(tid);
			if(bit!=barriermap.end()){
				mr.barrier=address;
				mr.occurrence="AFTER";
			}
			GetLock(&lock,tid+1);
			accessmap.insert( std::pair<ADDRINT,std::list<struct memregion> >(address,tlist) );
			OutFile << "Memory Address Inserted : " << ip << " W " <<  addr << "     " << address << "  TID : " << tid <<'\n';
			ReleaseLock(&lock);
		}
		else
		{
			mr.tid=tid;
                        mr.region_type=1;
                        mr.occurrence="";
                        std::list<struct memregion>::iterator tit;
                        int found = 0;
                        for(tit=it->second.begin();tit!=it->second.end();++tit){
      	                  if(tit->tid == tid){
                             if(tit->region_type!=1){
                	              bit=barriermap.find(tid);
        	                      if(bit!=barriermap.end()){
                                         mr.barrier=address;
                                         mr.occurrence="AFTER";
                                      }
                             }
                             found=1;
                             break;
                          }
                        }
                        if(found==0){
                                        mr.barrier=address;
                                        mr.occurrence="BEFORE";
                                        bit=barriermap.find(tid);
                                        if(bit!=barriermap.end()){
                                        std::list<ADDRINT>::iterator lit;
					int flag = 0;
                                        for(lit=bit->second.begin();lit!=bit->second.end();++lit){
                                        if(*lit==address){
                                                mr.occurrence="AFTER";
                                                flag=1;
                                        }
					}
                                        if(flag == 0)
                                        mr.occurrence="";
                                }
                                //std::list<struct memregion> tlist;
                                //tlist.push_back(mr);
                                it->second.push_back(mr);

				OutFile << "Shared Memory Declared : " << ip << " W " <<  addr << "     " << address << "  TID : " << tid <<endl;

				os << "Shared Exclusive Memory : Declared" << '\n';
				os << "Memory Address : " << address << '\n';
				os << "Instruction Address : " << addr << '\n';
				os << "Type of access : WRITE" << '\n';
				os << "Thread ID assigned by pin : " << tid << '\n';

				PIN_ApplicationBreakpoint(ctxt, tid, FALSE, os.str());
			}
		}
	}
	}
	*regSkipNextW = FALSE;
}

VOID Barrier(CONTEXT *ctxt, THREADID tid, ADDRINT addr)
{
	struct memregion mr;

        if (PIN_GetContextReg(ctxt, RegSkipNextR) == FALSE)
        {

        	PIN_SetContextReg(ctxt, RegSkipNextR, TRUE);
        	std::ostringstream os;
    		if(addr >= lowaddr && addr <= highaddr)
        	{
                //OutFile << "Enter : " << ip << " R " <<  addr << "     " << address << "  TID : " << tid <<'\n';
                //look up memory address
                bit=barriermap.find(tid);
                if(bit==barriermap.end())
                {
			std::list<ADDRINT> tlist;
			tlist.push_back(addr);
                        barriermap.insert(std::pair<THREADID,std::list<ADDRINT> >(tid, tlist) );
                }else{
                	//insert the barrier variable address at the end of the list
                	bit->second.push_back(addr);
		}
               
                it=accessmap.find(addr);
                if(it==accessmap.end())
                {
                	//assign values to memory region structure field
                        mr.tid=tid;
                        mr.region_type=0;
			mr.barrier=addr;
			mr.occurrence="";
			std::list<struct memregion> tlist;
			tlist.push_back(mr);
                        GetLock(&lock,tid+1);
                        accessmap.insert(std::pair<ADDRINT, std::list<struct memregion> >(addr, tlist) );
                        OutFile << "Memory Address Inserted : " << addr << "     " << "  TID : " << tid <<'\n';
                        ReleaseLock(&lock);
                }else{
			for(it2=accessmap.begin(); it2!=accessmap.end(); ++it2){
				std::list<struct memregion>::iterator lit;
				for(lit=it2->second.begin(); lit!=it2->second.end(); ++lit){
					if(lit->tid == tid){
						lit->occurrence="BEFORE";
					}
				}
			}	
		}
	}
	}
}
